////////////////////////////////////////////////////////////////////////////////
/// Данная программа генерирует две квадратные матрицы и перемножает их.
/// Все элементы исходных матрицы заполняются значением 1.0 для удобства проверки
/// результата - в результирующей матрице элементы должны быть равны размеру
/// исходных матриц (N).
///
/// Программа принимает на вход один необязательный аргумент:
///     - размер квадратных матриц N (значение по умолчанию = 50)
///
/// При изучении программы следует обратить внимание на следующие моменты:
/// 1. Использование функции omp_get_wtime для измерения времени работы участка кода.
///
/// С данным примером рекомендуется провести следующие эксперименты:
/// 1. Переставить директиву распараллеливания (#pragma omp parallel for) чтобы
///    распаралливать выполнение вложенных циклов и сравнить полученные результаты.
/// 2. При распараллеливании цикла по k убедиться что возникает ситуация "гонка"
///    (будут ошибки при проверке результатов умножения). Добавить в директиву
///    инструкцию для редукции по переменной sum с использованием оператора "+":
///    #pragma omp parallel for reduction(+:sum). Убедиться что ситуация "гонка"
///    больше не возникает.
/// 3. Указать что следует объеденить циклы по i и по j при распараллиливании с
///    помощью директивы #pragma omp parallel for collapse(2). Сравнить результаты.
/// 4. Указать что при размере матриц меньше 1000 не стоит создавать дополнительные
///    потоки путем добавления условия 'if(N > 1000)' в директиву компилятора.
///    Сравнить время работы программы при размерах матриц 900 и 1100 с временем
///    работы последовательной и параллельной версиями программы.
///
/// Задача перемножения квадратных матриц размерностью N*N имеет сложность O(N^3)
////////////////////////////////////////////////////////////////////////////////
 
#include <omp.h>
#include <cstdio>
#include <algorithm>

////////////////////////////////////////////////////////////////////////////////
// Выделение памяти под матрицу размером rows*cols
////////////////////////////////////////////////////////////////////////////////
double** create_matrix(size_t rows, size_t cols)
{
	double **M = new double*[rows];
	for (size_t i = 0; i < rows; ++i)
		M[i] = new double[cols];

	return M;
}

////////////////////////////////////////////////////////////////////////////////
// Освобождение памяти из под матрицы M размером rows*cols
////////////////////////////////////////////////////////////////////////////////
void delete_matrix(double** M, size_t rows, size_t cols)
{
	for (size_t i = 0; i < rows; ++i)
		delete[] M[i];
	delete[] M;
}

////////////////////////////////////////////////////////////////////////////////
// Заполнение матрицы M размером rows*cols единичными значениями
////////////////////////////////////////////////////////////////////////////////
void fill_matrix(double** M, size_t rows, size_t cols)
{
	for (size_t i = 0; i < rows; ++i)
		for (size_t j = 0; j < cols; ++j)
			M[i][j] = 1.0;
}

////////////////////////////////////////////////////////////////////////////////
// Проверка результатов перемножения единичных матриц
////////////////////////////////////////////////////////////////////////////////
void test_result(double** M, size_t rows, size_t cols, double result)
{
	for (size_t i = 0; i < rows; ++i)
		for (size_t j = 0; j < cols; ++j)
			if (M[i][j] != result)
				printf("M[%d][%d] = %6.1f\n", i, j, M[i][j]);
}

int main(int argc, char* argv[])
{
	// время запуска программы
	double t0 = omp_get_wtime();

	// определение размера решаемой задачи из параметров командной строки
	const size_t N = (argc == 2) ? atoi(argv[1]) : 50;

	// выделение памяти под матрицы
	double **A = create_matrix(N, N);
	double **B = create_matrix(N, N);
	double **C = create_matrix(N, N);

	// заполнение матриц случайными значениями
	fill_matrix(A, N, N);
	fill_matrix(B, N, N);

	// умножение матриц
	#pragma omp parallel for
	for (size_t i = 0; i < N; ++i)
	{
		for (size_t j = 0; j < N; ++j)
		{
			double sum = 0;
			for (size_t k = 0; k < N; ++k)
				sum += A[i][k] * B[k][j];
			C[i][j] = sum;
		}
	}

	// проверка результатов перемножения
	test_result(C, N, N, N);

	// освобожение памяти
	delete_matrix(A, N, N);
	delete_matrix(B, N, N);
	delete_matrix(C, N, N);

	// время окончания работы программы
	double t1 = omp_get_wtime();

	// вывод затраченного времени
	printf("Execution time   : %.5f s\n", t1-t0);	
	printf("Timer resolution : %.5f s\n", omp_get_wtick());

	return 0;
}
