////////////////////////////////////////////////////////////////////////////////
/// Данный пример занимается поиском простых чисел в заданном диапазоне.
/// Результом работы являются количество найденных чисел в указанном диапазоне.
///
/// Программа принимает на вход один аргумент:
///     - правую границу диапозона для поиска простых чисел
///
/// При изучении программы следует обратить внимание на следующие моменты:
/// 1. Использование атомарной операции.
///
/// С данным примером рекомендуется провести следующие эксперименты:
/// 1. Запустить программу для интервала [2 , 1000] несколько раз. Объяснить
///    отличие результатов.
/// 2. Исправить программу при помощи использования атомарной операции, для чего
///    раскоментировать строку "#pragma omp atomic" перед инкрементом переменной.
///    Сравнить результаты.
/// 3. Явно задать число создаваемых потоков при помощи num_threads.
///    Рекомендуемые значения: 16, 64, 256, 1024, 4096, 16384, 65536.
///    Обратить внимание как изменяется время выполнения.
/// 4. Явно указать дисциплину диспетчеризации потоков, рекомендуемые значения:
///    schedule(static, 1)
///    schedule(static, 2)
///    schedule(static, 3)
///    schedule(static, 1000)
///    schedule(dynamic, 1000)
///    Объяснить полученные результаты.
/// 5. Раскоментировать вывод найденных простых чисел на экран. Обратить внимание
///    на порядок выводимых чисел.
/// 6. Исправить ситуацию при помощи: #pragma omp ordered
///
/// Текущая реализация программы не является оптимальной для данной задачи,
/// предназначена для демонстрации особенностей OpenMP и имеет сложность O(N^(3/2))
///
/// Количество простых чисел до 1000     = 168
/// Количество простых чисел до 10000    = 1229
/// Количество простых чисел до 100000   = 9592
/// Количество простых чисел до 1000000  = 78498
/// Количество простых чисел до 10000000 = 664579
////////////////////////////////////////////////////////////////////////////////

#include <omp.h>
#include <cstdio>
#include <cmath>
#include <algorithm>

////////////////////////////////////////////////////////////////////////////////
// Функция для проверки, является ли заданное число простым
////////////////////////////////////////////////////////////////////////////////
bool is_prime(unsigned long x)
{
	unsigned long last = (long)floor(sqrt(x));
	for (unsigned long i = 2; i <= last; ++i)
		if ((x % i) == 0) return false;
	return true;
}

////////////////////////////////////////////////////////////////////////////////
// Основная программа
////////////////////////////////////////////////////////////////////////////////
int main(int argc, char *argv[])
{
	// время запуска программы
	double t0 = omp_get_wtime();

	// определение размера решаемой задачи из параметров командной строки
	const unsigned long N = (argc == 2) ? atol(argv[1]) : 30000000;

	// количество найденных простых чисел в диапазоне [2, N]
	unsigned long n_prime_numbers = 0;

	// запускаем расчеты
	printf("Searching prime numbers in interval [%lu, %lu]\n", 2, N);

	#pragma omp parallel for
	for (unsigned long i = 2; i < N; ++i)
	{
		if (is_prime(i))
		{
			//#pragma omp atomic
			++n_prime_numbers;

			//#pragma omp critical
			//printf("%lu\n", i);
		}
	}

	// вывод количества найденых простых чисел в диапазоне
	printf("Found %lu prime numbers\n", n_prime_numbers);

	// время окончания работы программы
	double t1 = omp_get_wtime();

	// вывод затраченного времени
	printf("Execution time   : %.5f s\n", t1-t0);	
	printf("Timer resolution : %.5f s\n", omp_get_wtick());

	return 0;
}
